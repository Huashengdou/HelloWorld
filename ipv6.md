- IPv6包由IPv6包头（40字节固定长度）、扩展包头和上层协议数据单元三部分组成。

- 128位的网络地址长度。由两个逻辑部分组成：64位网络前缀，64位主机地址。

- 总长度为128比特，通常分为8组，每组为4个十六进制数的形式，每组十六进制数间用冒号分隔。

- 常见格式：

  FC00:0000:130F:0000:0000:09C0:876A:130B

- 为书写方便，IPv6还提供了压缩格式，以上述IPv6地址为例，具体压缩规则为：

  - 每组中的前导“0”都可以省略，所以上述地址可写为：FC00:0:130F:0:0:9C0:876:130B；
  - 地址中包含的连续两个或多个均为0的组，可以用双冒号“：：”来代替，所以上述地址进一步简写为：FC00:0:130F::9C0:876A:130B;
  - 需要注意的是，在一个IPv6地址中只能使用一次双冒号“：：”，这是为了计算机将压缩后的地址恢复为128位时，能确认双冒号代表0的个数。

- 从一个进程到另一个进程的转换是由操作系统内核管理的。内核是操作系统代码常驻主存的部分。当应用程序需要操作系统的某些操作时，比如读写文件，他就执行一条特殊的系统调用指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。内核不是一个独立的进程，相反，他是系统管理全部进程所用代码和数据结构的集合。

- 指针提供了引用数据结构（包括数组）的元素的机制，与变量类似，指针也有两个方面：值和类型。他的值表示某个对象的位置，而他的类型表示那个位置上所存储对象的类型（比如整数或者浮点数）。

- 我们将程序成为“32位程序”或“64位程序”时，区别在于该程序是如何编译的，而不是其运行的机器类型。

- 对于跨越多字节的程序对象，必须建立两个规则：这个对象的地址是什么，以及在内存中如何排列这些字节。在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。

- 当执行一个运算时，如果他的一个运算数是有扶好的而另一个是无符号的，那么C语言会隐式地将有扶好参数强制类型转换为无符号数，并假设这两个数都是非负的，来执行这个运算。

- 当把short转换为unsigned时，我们先要改变大小，之后再完成从有符号到无符号的转换。也就是说（unsigned）sx等价于（unsigned）（int）sx。

- 在c语言中，不能够直接使用-2147483648（32位）来代替最小负数，因为这不是一个数字，在编译的时候会报告警。一般我们在定义最小负数的时候是用表达式-2147483647-1完成的。因为C语言中规定的取值范围是对称的，而补码规定的取值范围是非对称的。

- 检测无符号数加法中的溢出：对在范围0<=x,y<=UMax中的x和y，令s=x+y。则对计算s，当且仅当s<x（或者等价的s<y）时，发生了溢出。作为说明，在四位长的无符号加法中9+12=21（21超过了四位字长所表示的最大值15，所以9+12应为5），判断：由于5<9，所以我们判断发生了溢出。

- 两个数的w位补码之和与无符号数之和有完全相同的位级表示。实际上，大多数计算机使用同样的机器指令来执行无符号或者有符号加法。